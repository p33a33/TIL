# Today I leanred(21.01.21)
<br>

## Javascript concept 33
[33 Concpet Every Javascript Developer Should Know](https://github.com/leonardomso/33-js-concepts)

### 12. Bitwise Operator, Type Arrays and Array Buffers

이 개념이 실제 코드를 작성하거나, 리액트 작성에 도움이 될 일은 없으나, 언어가 동작하는 방법과 원리에 대한 이해라고 생각하고 공부하자.


* bit?
1. 컴퓨터에서 정보를 표현하는 2진숫자(0 or 1) 하나
2. 비트가 많으면 많을수록, 더 많은 순열을 통해 더 많은 정보를 표현할 수 있다.
3. 예를들어 113이라는 숫자를 2진수로 표현하면 아래와 같다.
```javascript
console.log(Number(113).toString(2)) // "111001"
```
4. 반대로 1111 이라는 2진수를 10진수로 변환하면 다음과 같다.
```javascript
console.log(parseInt(1111, 2)) // 15
```

* &(AND)
1. 일반적인 문법에서 사용하는 논리연산자 `&&`와 같이 작동한다.
2. 좌변과 우변에 있는 숫자의 비트값을 하나씩 비교한다.
3. 비교하는 자리의 값이 같으면 1을, 다르면 0을 반환한다.
4. 15와 12를 비교하는 과정을 살펴보면 다음과 같다.

    1. 12의 비트값을 확인 => `1100`
    2. 15의 비트값을 확인 => `1111`

    3.  첫째자리 비교 => 같음 => 1

        둘째자리 비교 => 같음 => 1

        셋째자리 비교 => 다름 => 0

        넷째자리 비교 => 다름 => 0

    4. `1100`에 해당하는 10진수 12 반환.

```javascript
console.log(12 & 15) // 12
```


<br>

*  | (OR)
1. 논리연산자 `||`와 같이 작동한다.
2. 좌우변의 비트를 하나씩 비교하면서, 좌변이나 우변 둘중 하나만 1이어도 1을 반환한다. 
3. 15와 12를 비교해보자.
    1. 둘의 비트값 `1100`, `1111`을 비교한다.
    2. 비교결과가 어떻든 1을 반환하므로, 반환값은 2진수 `1111`
    3. 이를 10진수로 변환하여 표시하므로 `15`가 반환됨.

<br>

* ~ (NOT)
1. 주어진 숫자의 비트값을 반전하여 반환한다.
2. `~15`가 어떻게 계산되는지 알아보자.
    1. `15`의 2진수 `1111`에 `1`을 더한다. (2진수는 2개의 숫자로만 표현되므로, 1을 더하면 모든 값이 반전된다.)
    2. `10000`이 된다.
    3. 양수-음수를 반전한다.
    4. `-10000`을 10진수로 반환한다 `-21`반환.

<br>

* ^ (XOR)
1. XOR = exclusive OR
2. AND나 OR 처럼 양쪽의 비트를 비교하고, 양쪽의 비트가 다를 경우 1을 반환한다.
3. 15와 12를 XOR 연산으로 비교해보자.
    1. 둘의 비트값 `1100`, `1111`을 비교한다.
    2. 비교결과 양쪽 비트가 다를 경우 1을 반환한다. `0011`이 반환된다.
    3. `11`를 10진수로 반환하면, `3`

<br>

* Shifting Operators
1. 비트의 Shifting(이동)에 관여하는 연산자는 `>>`와 `<<`가 있음.
2. `<<`는 주어진 값의 비트값을 좌측으로 n자리 옮긴다.
    1. 자리를 이동할때마다 실제 값이 2배씩 증가. (2진수니까 당연하지..)
```javascript
15 << 0 // 1111<-0번, 15
15 << 1 // 11110 왼쪽으로 1자리 이동, 빈 자리는 0으로 채움., 30
15 << 2 // 111100 왼쪽으로 2자리 이동, 60
15 << 3 // 1111000 왼쪽으로 3자리 이동, 120
```
3. `>>`는 주어진 비트를 우측으로 n자리 옮긴다.
```javascript
15 >> 0 // 1111 15
15 >> 1 // 0111 오른쪽으로 1자리 이동, 마지막자리 짤림, 빈 자리는 0으로 채움, 7
15 >> 2 // 0011 오른쪽으로 2자리 이동, 3
15 >> 3 // 0001 오른쪽으로 3자리 이동, 1
15 >> 4 // 0000, 오른쪽으로 4자리 이동, 0
``` 
4. 음수의 `>>`
```javascript
-16 >> 0 //  -10000
-16 >> 1 //  -01000, -8
...
-16 >> 4 //  -00001, -1
-16 >> 5 // -00001, -1 

/*
숫자를 나타내는 비트의 첫번째 비트는 음수와 양수를 구별하기위해 사용됨.
양수의 경우 0, 음수의 경우 1을 사용함.
따라서, 음수를 아무리 우측으로 shifting하더라도 0이 아니라 음수를 나타내는 -1이 반환된다.
*/
```

<br>

* Bit manipulation
1. 위처럼 비트연산이 가능함을 이해했다면, 이를 이용해서 유용한 도구로 사용할수도 있다.
2. 비트를 원하는 값으로 수정하기위해서 `masks`라는 개념을 사용한다.
3. `masks`는 2진수 형태로, 목표로 하는바가 무엇인가에 따라서 달라진다.
4. 만약에 (오른쪽에서) 첫번째 자리를 1로 수정하고 싶으면 여기에 필요한 `mask`는 이진수 `1`이 된다. 두번째 자리를 수정하고싶으면? `10`이 될 것이다.
5. 아래의 예제를 살펴보자.
```javascript
    const setBit = (num, position) => {
        let mask = 1 << position // 수정이 필요한 위치에 따라 mask를 정의한다.
        return num | mask // 1100 | 10 => 1110
    }

    setBit(12, 1) // return 14 -> 1110
```

6. 그렇다면 원하는 자리를 0으로 수정하고 싶으면 어떻게 처리해야하는가?
```javascript
    const clearBit = (num, position) => {
        let mask = ~(1 << position) // mask를 정의한다. -11
        return num & mask // 1111 & -101 =>  1101
    }

    clearBit(15, 1) // 13 -> 1101
```

* 여기서 왜 `10`의 NOT인 `-101`과 `111`의 AND가 `1101`이 나오는가?
    음수는 음수임을 나타내기위해 앞자리가 모두 1로 변환된다.
    실제로 -3의 비트값은 `11111111111111111111111111111101`에 해당한다.
    음수는 음수를 표현하기위해 `32bit-int`로 자동으로 변환되며, 양수와 연산하는 경우, 양수도 자리를 맞추어 `32bit-int`로 변환된다.

실제 15 & -3의 연산은 다음과 같다.

_15_  =   0    0   0   0   0   0   0   0   0   0    0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   1   1	

_-3_ = 	    1    1   1   1   1  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   0   1

_13_ = 	0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   1 

실제 계산은 [bitwisecmd.com](https://bitwisecmd.com/)에서 해볼 수 있다.

7. 마지막으로, 해당 위치가 0인지 1인지 모르는 상태에서 이를 반대로(0이면 1로, 1이면 0으로) 처리하는 방법은 다음과 같다.

```javascript
    const flipBit = (num, position) => {
        let mask = 1 << position // 10
        return num ^ mask // 1111 ^ 0010 = 1101 (둘다 1이면 0 반환)
    }

    flipBit(15, 1) // 13, 1101
```

[참고 링크](https://hackernoon.com/programming-with-js-bitwise-operations-393eb0745dc4)